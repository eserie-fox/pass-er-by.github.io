<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-大一上,苦恼" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/19/%E5%A4%A7%E4%B8%80%E4%B8%8A,%E8%8B%A6%E6%81%BC/" class="article-date">
  <time datetime="2019-12-19T02:40:55.550Z" itemprop="datePublished">2019-12-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/19/%E5%A4%A7%E4%B8%80%E4%B8%8A,%E8%8B%A6%E6%81%BC/">大一上,苦恼</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="大一上的颓废"><a href="#大一上的颓废" class="headerlink" title="大一上的颓废"></a>大一上的颓废</h1><hr>
<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>&emsp;&emsp;距离7月份10来号初来学校学习，已经有5个月左右了。因为高考失利，没能去计院，心中还是有些苦闷。在别的院，心里或多或少有些苦闷，在这样的心情下，我浑浑噩噩度过了这5个月。</p>
<p>&emsp;&emsp;这段时间里，感觉自己不像自己。我无法将自己投入进自己想做的事情中去。我不得不努力学习高数之类的，因为我很想转专业，转到计院，专心于计算机。而当前所在学院转出门槛有点高，要求总成绩在前5%或者10%(依每年情况而定，他们当然不希望有学生转走);另一方面，计院那边也有转入门槛，这使得我心里很没底，我不知道自己的努力能不能达成。如果再努力也无法达成的话，我或许会放弃，但事实又是它有一些微弱的希望。这希望又吊起我，让我又以放弃与坚持中间徘徊的心态继续努力。这样的学习生活让我心憔悴，让我身劳累。我多么希望能抽出更多时间做其他事情。</p>
<p>&emsp;&emsp;万幸的是，我不是孤单的。我还有处于同样处境的朋友。他们甚至比我更加努力，让我有了一个追赶的目标，让我不一昧沉迷于迷茫。但我仍然不满意于这一切，追赶这些并非完全由我意志所选择的目标，我认为我是颓废的。</p>
<hr>
<h3 id="课外"><a href="#课外" class="headerlink" title="课外"></a>课外</h3><p>&emsp;&emsp;我自认为，我爱纯真，爱童心，爱游戏。但自从上了大学，这和想象不同的大学生活，让我更少去思考，去回归最初的心。我曾计划着在大学课余，多读书，多玩游戏，但显然，快节奏的、不知如何被占满的日常，让我不能沉心于书本，让我的游戏时间被挤占。这些也只是借口，但理想和现实的差距是真实的。</p>
<p>&emsp;&emsp;也有做了一些差强人意的决定。我加入了ACM-ICPC的校队，加入了游戏制作社。对于ACM-ICPC，我不愿评价。对于游戏制作社，我则有一种纠结。一方面，我爱，或者说想让自己爱游戏。另一方面，这样的事情也会占用很多时间，而且对我来说，从事游戏行业这样的未来的是不太明朗的。</p>
<hr>
<h4 id="11月-中旬"><a href="#11月-中旬" class="headerlink" title="11月 中旬"></a>11月 中旬</h4><p>实际15日上午出发，午间到达银川，下午4、5点的样子到达沈阳。出机场，寒风刺骨，外面飘着雪。第一次亲眼见识到铺满地面的雪,<del>去酒店途中也做了很多南方人的行为</del>。</p>
<p><img src="https://raw.githubusercontent.com/pass-er-by/imagehost/master/image/IMG_20191116_113053.jpg" alt="2019ACMICPC亚洲区域赛沈阳站签到处门口"><br>签到拿了个马甲，上面贴了沈阳站LOGO。</p>
<p><img src="https://raw.githubusercontent.com/pass-er-by/imagehost/master/image/IMG_20191116_113042.jpg" alt="上图转身，东北大学的一个小广场"></p>
<p>&emsp;&emsp;这场比赛让我体会到绝望，我正巧比赛前学了多项式，但没有实际用一下，使得本场比赛中有一道多项式的题没有出。而那道题本可以让我们拿金，让sjj也能拿金退役。可惜我没能熟悉那个多项式板子。这是我们队的一个遗憾。但总之，事情已经过去，我没法改变过去，我只能重新向前进发。</p>
<p><img src="https://raw.githubusercontent.com/pass-er-by/imagehost/master/image/IMG_20191117_151740.jpg" alt="我们队的银牌，由sjj保存"></p>
<hr>
<h4 id="12月-上旬"><a href="#12月-上旬" class="headerlink" title="12月 上旬"></a>12月 上旬</h4><p>5号晚上出发，第一次去上海。上海的风真是大哇。</p>
<p>6号有幸参加了游戏开发者大会。<br><img src="https://raw.githubusercontent.com/pass-er-by/imagehost/master/image/IMG_20191206_131356.jpg" alt="游戏开发者大会，中午休息时"></p>
<p>7号8号 </p>
<h5 id="6号和7号晚上"><a href="#6号和7号晚上" class="headerlink" title="6号和7号晚上"></a>6号和7号晚上</h5><p>&emsp;&emsp;和工作室的前辈们玩了很久游戏，很开心。庆幸自己热爱游戏。</p>
<h5 id="weplay展会"><a href="#weplay展会" class="headerlink" title="weplay展会"></a>weplay展会</h5><p><img src="https://raw.githubusercontent.com/pass-er-by/imagehost/master/image/IMG_20191207_090136.jpg" alt="以工作人员身份，提前入场"></p>
<p>&emsp;&emsp;有幸作为独立游戏大赛入选选手(实际蹭的游戏工作室前辈的光)，以工作人员的身份提前进场。拿到了第一张，zun会场的招待券~。hhh<br><img src="https://raw.githubusercontent.com/pass-er-by/imagehost/master/image/weplay_zun1.jpg" alt="摄于7号中午,有幸见到神主"><br>外面有很多可怜人，没能拿到招待券，还因人群过于密集被警察清场。</p>
<p>&emsp;&emsp;期间守了自己游戏摊位，为玩家讲解游戏。我自认为游戏还不够完善，不够有趣，去给他人介绍时，他人因也不好拒绝我，抽出时间玩了一会还不太完善、有趣的游戏。</p>
<p>&emsp;&emsp;守摊期间遇见几个发行商，他们真是很老练。</p>
<hr>
<p>&emsp;&emsp;这两次我都翘了点课，感觉到了一点印象中的大学的味道。这是自由，青春的味道吗？</p>
<hr>
<p>&emsp;&emsp;大一上尽管有两次愉快的外出，但到大多时间是烦闷颓废的，我很多时候做着不想做的事情，我甚至没有勇气尝试一些我想尝试的事。我借这个记录，记录一些快乐，记录一些颓废的烦闷和后悔，在大一下，一定要让自己更加接近心中的自己。</p>
<h3 id="记于2019年12月19日"><a href="#记于2019年12月19日" class="headerlink" title="记于2019年12月19日"></a>记于2019年12月19日</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/19/%E5%A4%A7%E4%B8%80%E4%B8%8A,%E8%8B%A6%E6%81%BC/" data-id="ck4c4gomj0002f8qfa8jl2800" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-polyarray" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/13/polyarray/" class="article-date">
  <time datetime="2019-12-13T07:56:04.921Z" itemprop="datePublished">2019-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/13/polyarray/">polyarray</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>(```)</p>
<pre><code>#define ll long long
using namespace std;
const double PI = 3.14159265358979323846;
const int MAXN = 1e5 + 33;
//定义Complex类
class Complex
{
public:
    double r, i;
    Complex(double rr = 0, double ii = 0) { r = rr, i = ii; }
    Complex operator+(const Complex &amp;op) const { return Complex(r + op.r, i + op.i); }
    Complex operator-(const Complex &amp;op) const { return Complex(r - op.r, i - op.i); }
    Complex operator*(const Complex &amp;op) const { return Complex(r * op.r - i * op.i, i * op.r + r * op.i); }
};

int Round(double x)
{
    return int(x + 0.5);
}
ll qp(ll x, ll y, ll MOD)
{
    ll ret = 1;
    while (y &gt; 0)
    {
        if (y &amp; 1)
            ret = ret * x % MOD;
        x = x * x % MOD;
        y &gt;&gt;= 1;
    }
    return ret;
}

namespace FFT_template
{
Complex temp1[MAXN &lt;&lt; 2], temp2[MAXN &lt;&lt; 2];
void brc(Complex *p, int N)
{
    int i, j, k;
    for (i = 1, j = N &gt;&gt; 1; i &lt; N - 2; i++)
    {
        if (i &lt; j)
            swap(p[i], p[j]);
        for (k = N &gt;&gt; 1; j &gt;= k; k &gt;&gt;= 1)
            j -= k;
        if (j &lt; k)
            j += k;
    }
}
void FFT(Complex *p, int N, int op) //op==1 为正变换，op==-1为逆变换
{
    brc(p, N);
    double p0 = PI * op;
    for (int h = 2; h &lt;= N; h &lt;&lt;= 1, p0 *= 0.5)
    {
        int hf = h &gt;&gt; 1;
        Complex unit(cos(p0), sin(p0));
        for (int i = 0; i &lt; N; i += h)
        {
            Complex w(1.0, 0.0);
            for (int j = i; j &lt; i + hf; j++)
            {
                Complex u = p[j], v = w * p[j + hf];
                p[j] = u + v;
                p[j + hf] = u - v;
                w = w * unit;
            }
        }
    }
    if (op == -1)
        for (int i = 0; i &lt; N; i++)
            p[i].r /= N;
}
} // namespace FFT_template
using namespace FFT_template;

namespace NTT_templates
{
// 998244353 原根为 3，1004535809 原根为 3，786433 原根为 10，880803841 原根为 26
const int MOD = 998244353, wroot = 3;
int wi[MAXN &lt;&lt; 2];
void brc(int *p, int N)
{
    int i, j, k;
    for (i = 1, j = N &gt;&gt; 1; i &lt; N - 2; i++)
    {
        if (i &lt; j)
            swap(p[i], p[j]);
        for (k = N &gt;&gt; 1; j &gt;= k; k &gt;&gt;= 1)
            j -= k;
        if (j &lt; k)
            j += k;
    }
}
void NTT_init(int N) //使用NTT之前调用,且N要保持一致,为2的幂
{
    wi[0] = 1;
    wi[1] = qp(wroot, (MOD - 1) / N, MOD);
    for (int i = 2; i &lt;= N; i++)
        wi[i] = (ll)wi[i - 1] * (ll)wi[1] % MOD;
}
void NTT(int *p, int N, int op)
{
    brc(p, N);
    for (int h = 2; h &lt;= N; h &lt;&lt;= 1)
    {
        int unit = ((op == -1) ? (N - N / h) : (N / h));
        int hf = h &gt;&gt; 1;
        for (int i = 0; i &lt; N; i += h)
        {
            int w = 0;
            for (int j = i; j &lt; i + hf; j++)
            {
                int u = p[j], v = (ll)wi[w] * (ll)p[j + hf] % MOD;
                if ((p[j] = u + v) &gt;= MOD)
                    p[j] -= MOD;
                if ((p[j + hf] = u - v) &lt; 0)
                    p[j + hf] += MOD;
                if ((w += unit) &gt;= N)
                    w -= N;
            }
        }
    }
    if (op == -1)
    {
        int inv = qp(N, MOD - 2, MOD);
        for (int i = 0; i &lt; N; i++)
            p[i] = (ll)p[i] * (ll)inv % MOD;
    }
}
} // namespace NTT_templates
using namespace NTT_templates;

namespace Polynomial_mul
{
int temp11[MAXN &lt;&lt; 2], temp22[MAXN &lt;&lt; 2];
//对于给定n次多项式a和b,多项式res=a*b (可能有精度损失)
void Poly_mul_FFT(int *a, int *b, int *res, int n) //n为最高次项次数
{
    int N = 2;
    while (N &lt;= n + n)
        N &lt;&lt;= 1;
    Complex *A = temp1,
            *B = temp2;
    for (int i = 0; i &lt;= n; i++)
        A[i] = Complex(a[i], 0.0);
    for (int i = 0; i &lt;= n; i++)
        B[i] = Complex(b[i], 0.0);
    FFT(A, N, 1);
    FFT(B, N, 1);
    for (int i = 0; i &lt; N; i++)
        A[i] = A[i] * B[i];
    FFT(A, N, -1);
    for (int i = 0; i &lt; N; i++)
        res[i] = Round(A[i].r);
}
//对于给定n次多项式a和b,求出模MOD下的多项式res=a*b
void Poly_mul(int *a, int *b, int *res, int n)
{
    int N = 2;
    while (N &lt;= n + n)
        N &lt;&lt;= 1;
    NTT_init(N);
    int *A = temp11,
        *B = temp22;
    for (int i = 0; i &lt; N; i++)
        A[i] = a[i];
    for (int i = 0; i &lt; N; i++)
        B[i] = b[i];
    NTT(A, N, 1);
    NTT(B, N, 1);
    for (int i = 0; i &lt; N; i++)
        A[i] = (ll)A[i] * (ll)B[i] % MOD;
    NTT(A, N, -1);
    for (int i = 0; i &lt; N; i++)
        res[i] = A[i];
}
} // namespace Polynomial_mul
using namespace Polynomial_mul;

//
int numinv[MAXN &lt;&lt; 1];
//返回模MOD意义下x的逆元 MOD为质数
int get_num_inv(int x)
{
    if (x &lt; (MAXN &lt;&lt; 1))
    {
        if (numinv[x])
            return numinv[x];
        return numinv[x] = qp(x, MOD - 2, MOD);
    }
    return qp(x, MOD - 2, MOD);
}
//

//对n次多项式p求导得模MOD意义下的多项式res
void Poly_derivative(int *p, int *res, int n)
{
    for (int i = 0; i &lt;= n - 1; i++)
        res[i] = (ll)p[i + 1] * (i + 1) % MOD;
    res[n] = 0;
}
//对n次多项式p积分得模MOD意义下的多项式res 且res[0]=0;
void Poly_integral(int *p, int *res, int n)
{
    for (int i = n; i &gt;= 1; i--)
        res[i] = (ll)p[i - 1] * (ll)get_num_inv(i) % MOD;
    res[0] = 0;
}

namespace Polynomial_inv
{
int tmp[MAXN &lt;&lt; 2], tmp2[MAXN &lt;&lt; 2];
void get_poly_inv(int *p, int *res, int N) //N是2的幂,一般不调用此函数 为项数,而非次数
{
    if (N &lt;= 1)
    {
        res[0] = qp(p[0], MOD - 2, MOD);
        return;
    }
    get_poly_inv(p, res, N &gt;&gt; 1);
    int K = N &lt;&lt; 1;
    int *temp = tmp;
    for (int i = 0; i &lt; N; i++)
        temp[i] = p[i];
    for (int i = N; i &lt; K; i++)
        temp[i] = res[i] = 0;
    NTT_init(K);
    NTT(temp, K, 1);
    NTT(res, K, 1);
    // cout &lt;&lt; temp[0] &lt;&lt; &quot; &quot; &lt;&lt; res[0] &lt;&lt; endl;
    for (int i = 0; i &lt; K; i++)
    {
        res[i] = (ll)res[i] * (2 - (ll)temp[i] * (ll)res[i] % MOD) % MOD;
        if (res[i] &lt; 0)
            res[i] += MOD;
    }
    NTT(res, K, -1);
    // for (int i = 0; i &lt; K; i++)
    //     cout &lt;&lt; res[i] &lt;&lt; &apos; &apos;;
    // cout &lt;&lt; res[0] &lt;&lt; endl;
    for (int i = N; i &lt; K; i++)
        res[i] = 0;
}
//对给定n次多项式p,求出其模MOD以及x^(n+1)意义下的逆多项式res
void Poly_inv(int *p, int *res, int n) //n是最高次项次数 模x^(n+1) 系数模MOD 一般调用此函数
{
    int N = 2;
    while (N &lt;= n)
        N &lt;&lt;= 1;
    int dN = N &lt;&lt; 1;
    int *temp = tmp2;
    for (int i = 0; i &lt; dN; i++)
        temp[i] = 0;
    get_poly_inv(p, temp, N);
    for (int i = 0; i &lt;= n; i++)
        res[i] = temp[i];
}
} // namespace Polynomial_inv
using namespace Polynomial_inv;

namespace Polynomial_ln
{
int tmp[MAXN &lt;&lt; 2], tmp2[MAXN &lt;&lt; 2];
void get_poly_ln(int *p, int *res, int N) //N为2的幂 为项数,而非次数
{
    int *temp = tmp;
    get_poly_inv(p, temp, N);
    int K = N &lt;&lt; 1;
    Poly_derivative(p, res, N - 1);
    for (int i = N; i &lt; K; i++)
        res[i] = 0;
    NTT_init(K);
    NTT(res, K, 1);
    NTT(temp, K, 1);
    for (int i = 0; i &lt; K; i++)
        res[i] = (ll)res[i] * temp[i] % MOD;
    NTT(res, K, -1);
    Poly_integral(res, res, N - 1);
}
//对给定n次多项式p (且p[0]==1) ,求出其模MOD以及x^(n+1)意义下的多项式res==ln(p)
void Poly_ln(int *p, int *res, int n) //n为最高项次数
{
    int N = 2;
    while (N &lt;= n)
        N &lt;&lt;= 1;
    int *temp = tmp2;
    get_poly_ln(p, temp, N);
    for (int i = 0; i &lt;= n; i++)
        res[i] = temp[i];
}
} // namespace Polynomial_ln
using namespace Polynomial_ln;

namespace Polynomial_exp
{
int tmp[MAXN &lt;&lt; 2], tmp2[MAXN &lt;&lt; 2];
void get_poly_exp(int *p, int *res, int N) //N为2的幂 为项数,而非次数
{
    if (N &lt;= 1)
    {
        res[0] = 1;
        return;
    }
    get_poly_exp(p, res, N &gt;&gt; 1);
    int *temp = tmp;
    get_poly_ln(res, temp, N);
    int K = N &lt;&lt; 1;
    for (int i = 0; i &lt; N; i++)
    {
        temp[i] = p[i] - temp[i];
        if (temp[i] &lt; 0)
            temp[i] += MOD;
    }
    if ((++temp[0]) == MOD)
        temp[0] = 0;
    for (int i = N; i &lt; K; i++)
        temp[i] = res[i] = 0;
    NTT_init(K);
    NTT(temp, K, 1);
    NTT(res, K, 1);
    for (int i = 0; i &lt; K; i++)
        res[i] = (ll)res[i] * (ll)temp[i] % MOD;
    NTT(res, K, -1);
    for (int i = N; i &lt; K; i++)
        res[i] = 0;
}
//对给定n次多项式p (且p[0]==0) ,求出其模MOD以及x^(n+1)意义下的多项式res==exp(p)
void Poly_exp(int *p, int *res, int n)
{
    int N = 2;
    while (N &lt;= n)
        N &lt;&lt;= 1;
    int *temp = tmp2;
    get_poly_exp(p, temp, N);
    for (int i = 0; i &lt;= n; i++)
        res[i] = temp[i];
}
} // namespace Polynomial_exp
using namespace Polynomial_exp;</code></pre><p>(```)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/13/polyarray/" data-id="ck4c4gomi0001f8qfciul5rbe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mypoly" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/12/mypoly/" class="article-date">
  <time datetime="2019-12-12T15:31:01.509Z" itemprop="datePublished">2019-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/12/mypoly/">mypoly</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>(```)</p>
<pre><code>#define ll long long
using namespace std;
const double PI = 3.14159265358979323846;
const int MAXN = 1e6 + 33;
//定义Complex类
class Complex
{
public:
    double r, i;
    Complex(double rr = 0, double ii = 0) { r = rr, i = ii; }
    Complex operator+(const Complex &amp;op) const { return Complex(r + op.r, i + op.i); }
    Complex operator-(const Complex &amp;op) const { return Complex(r - op.r, i - op.i); }
    Complex operator*(const Complex &amp;op) const { return Complex(r * op.r - i * op.i, i * op.r + r * op.i); }
};

int Round(double x)
{
    return int(x + 0.5);
}
ll qp(ll x, ll y, ll MOD)
{
    ll ret = 1;
    while (y &gt; 0)
    {
        if (y &amp; 1)
            ret = ret * x % MOD;
        x = x * x % MOD;
        y &gt;&gt;= 1;
    }
    return ret;
}

namespace FFT_template
{
void brc(Complex *p, int N)
{
    int i, j, k;
    for (i = 1, j = N &gt;&gt; 1; i &lt; N - 2; i++)
    {
        if (i &lt; j)
            swap(p[i], p[j]);
        for (k = N &gt;&gt; 1; j &gt;= k; k &gt;&gt;= 1)
            j -= k;
        if (j &lt; k)
            j += k;
    }
}
void FFT(Complex *p, int N, int op) //op==1 为正变换，op==-1为逆变换
{
    brc(p, N);
    double p0 = PI * op;
    for (int h = 2; h &lt;= N; h &lt;&lt;= 1, p0 *= 0.5)
    {
        int hf = h &gt;&gt; 1;
        Complex unit(cos(p0), sin(p0));
        for (int i = 0; i &lt; N; i += h)
        {
            Complex w(1.0, 0.0);
            for (int j = i; j &lt; i + hf; j++)
            {
                Complex u = p[j], v = w * p[j + hf];
                p[j] = u + v;
                p[j + hf] = u - v;
                w = w * unit;
            }
        }
    }
    if (op == -1)
        for (int i = 0; i &lt; N; i++)
            p[i].r /= N;
}
} // namespace FFT_template
using namespace FFT_template;

namespace NTT_templates
{
// 998244353 原根为 3，1004535809 原根为 3，786433 原根为 10，880803841 原根为 26
const int MOD = 998244353, wroot = 3;
int wi[MAXN &lt;&lt; 2];
void brc(int *p, int N)
{
    int i, j, k;
    for (i = 1, j = N &gt;&gt; 1; i &lt; N - 2; i++)
    {
        if (i &lt; j)
            swap(p[i], p[j]);
        for (k = N &gt;&gt; 1; j &gt;= k; k &gt;&gt;= 1)
            j -= k;
        if (j &lt; k)
            j += k;
    }
}
void NTT_init(int N) //使用NTT之前调用,且N要保持一致,为2的幂
{
    wi[0] = 1;
    wi[1] = qp(wroot, (MOD - 1) / N, MOD);
    for (int i = 2; i &lt;= N; i++)
        wi[i] = (ll)wi[i - 1] * (ll)wi[1] % MOD;
}
void NTT(int *p, int N, int op)
{
    brc(p, N);
    for (int h = 2; h &lt;= N; h &lt;&lt;= 1)
    {
        int unit = ((op == -1) ? (N - N / h) : (N / h));
        int hf = h &gt;&gt; 1;
        for (int i = 0; i &lt; N; i += h)
        {
            int w = 0;
            for (int j = i; j &lt; i + hf; j++)
            {
                int u = p[j], v = (ll)wi[w] * (ll)p[j + hf] % MOD;
                if ((p[j] = u + v) &gt;= MOD)
                    p[j] -= MOD;
                if ((p[j + hf] = u - v) &lt; 0)
                    p[j + hf] += MOD;
                if ((w += unit) &gt;= N)
                    w -= N;
            }
        }
    }
    if (op == -1)
    {
        int inv = qp(N, MOD - 2, MOD);
        for (int i = 0; i &lt; N; i++)
            p[i] = (ll)p[i] * (ll)inv % MOD;
    }
}
} // namespace NTT_templates
using namespace NTT_templates;

namespace Polynomial_mul
{
//对于给定n次多项式a和b,多项式res=a*b (可能有精度损失)
void Poly_mul_FFT(int *a, int *b, int *res, int n) //n为最高次项次数
{
    int N = 2;
    while (N &lt;= n + n)
        N &lt;&lt;= 1;
    Complex *A = new Complex[N + 1],
            *B = new Complex[N + 1];
    for (int i = 0; i &lt;= n; i++)
        A[i] = Complex(a[i], 0.0);
    for (int i = 0; i &lt;= n; i++)
        B[i] = Complex(b[i], 0.0);
    FFT(A, N, 1);
    FFT(B, N, 1);
    for (int i = 0; i &lt; N; i++)
        A[i] = A[i] * B[i];
    FFT(A, N, -1);
    for (int i = 0; i &lt; N; i++)
        res[i] = Round(A[i].r);
    delete[] A;
    delete[] B;
}
//对于给定n次多项式a和b,求出模MOD下的多项式res=a*b
void Poly_mul(int *a, int *b, int *res, int n)
{
    int N = 2;
    while (N &lt;= n + n)
        N &lt;&lt;= 1;
    NTT_init(N);
    int *A = new int[N + 1],
        *B = new int[N + 1];
    for (int i = 0; i &lt; N; i++)
        A[i] = a[i];
    for (int i = 0; i &lt; N; i++)
        B[i] = b[i];
    NTT(A, N, 1);
    NTT(B, N, 1);
    for (int i = 0; i &lt; N; i++)
        A[i] = (ll)A[i] * (ll)B[i] % MOD;
    NTT(A, N, -1);
    for (int i = 0; i &lt; N; i++)
        res[i] = A[i];
    delete[] A;
    delete[] B;
}
} // namespace Polynomial_mul
using namespace Polynomial_mul;

//
int numinv[MAXN &lt;&lt; 1];
//返回模MOD意义下x的逆元 MOD为质数
int get_num_inv(int x)
{
    if (x &lt; (MAXN &lt;&lt; 1))
    {
        if (numinv[x])
            return numinv[x];
        return numinv[x] = qp(x, MOD - 2, MOD);
    }
    return qp(x, MOD - 2, MOD);
}
//

//对n次多项式p求导得模MOD意义下的多项式res
void Poly_derivative(int *p, int *res, int n)
{
    for (int i = 0; i &lt;= n - 1; i++)
        res[i] = (ll)p[i + 1] * (i + 1) % MOD;
    res[n] = 0;
}
//对n次多项式p积分得模MOD意义下的多项式res 且res[0]=0;
void Poly_integral(int *p, int *res, int n)
{
    for (int i = n; i &gt;= 1; i--)
        res[i] = (ll)p[i - 1] * (ll)get_num_inv(i) % MOD;
    res[0] = 0;
}

namespace Polynomial_inv
{
void get_poly_inv(int *p, int *res, int N) //N是2的幂,一般不调用此函数 为项数,而非次数
{
    if (N &lt;= 1)
    {
        res[0] = qp(p[0], MOD - 2, MOD);
        return;
    }
    get_poly_inv(p, res, N &gt;&gt; 1);
    int K = N &lt;&lt; 1;
    int *temp = new int[K + 1];
    for (int i = 0; i &lt; N; i++)
        temp[i] = p[i];
    for (int i = N; i &lt; K; i++)
        temp[i] = res[i] = 0;
    NTT_init(K);
    NTT(temp, K, 1);
    NTT(res, K, 1);
    // cout &lt;&lt; temp[0] &lt;&lt; &quot; &quot; &lt;&lt; res[0] &lt;&lt; endl;
    for (int i = 0; i &lt; K; i++)
    {
        res[i] = (ll)res[i] * (2 - (ll)temp[i] * (ll)res[i] % MOD) % MOD;
        if (res[i] &lt; 0)
            res[i] += MOD;
    }
    NTT(res, K, -1);
    // for (int i = 0; i &lt; K; i++)
    //     cout &lt;&lt; res[i] &lt;&lt; &apos; &apos;;
    // cout &lt;&lt; res[0] &lt;&lt; endl;
    for (int i = N; i &lt; K; i++)
        res[i] = 0;
    delete[] temp;
}
//对给定n次多项式p,求出其模MOD以及x^(n+1)意义下的逆多项式res
void Poly_inv(int *p, int *res, int n) //n是最高次项次数 模x^(n+1) 系数模MOD 一般调用此函数
{
    int N = 2;
    while (N &lt;= n)
        N &lt;&lt;= 1;
    int dN = N &lt;&lt; 1;
    int *temp = new int[dN + 1];
    for (int i = 0; i &lt; dN; i++)
        temp[i] = 0;
    get_poly_inv(p, temp, N);
    for (int i = 0; i &lt;= n; i++)
        res[i] = temp[i];
    delete[] temp;
}
} // namespace Polynomial_inv
using namespace Polynomial_inv;

namespace Polynomial_ln
{
void get_poly_ln(int *p, int *res, int N) //N为2的幂 为项数,而非次数
{
    int *temp = new int[(N &lt;&lt; 1) + 1];
    get_poly_inv(p, temp, N);
    int K = N &lt;&lt; 1;
    Poly_derivative(p, res, N - 1);
    for (int i = N; i &lt; K; i++)
        res[i] = 0;
    NTT_init(K);
    NTT(res, K, 1);
    NTT(temp, K, 1);
    for (int i = 0; i &lt; K; i++)
        res[i] = (ll)res[i] * temp[i] % MOD;
    NTT(res, K, -1);
    Poly_integral(res, res, N - 1);
    delete[] temp;
}
//对给定n次多项式p (且p[0]==1) ,求出其模MOD以及x^(n+1)意义下的多项式res==ln(p)
void Poly_ln(int *p, int *res, int n) //n为最高项次数
{
    int N = 2;
    while (N &lt;= n)
        N &lt;&lt;= 1;
    int *temp = new int[(N &lt;&lt; 1) + 1];
    get_poly_ln(p, temp, N);
    for (int i = 0; i &lt;= n; i++)
        res[i] = temp[i];
    delete[] temp;
}
} // namespace Polynomial_ln
using namespace Polynomial_ln;

namespace Polynomial_exp
{
void get_poly_exp(int *p, int *res, int N) //N为2的幂 为项数,而非次数
{
    if (N &lt;= 1)
    {
        res[0] = 1;
        return;
    }
    get_poly_exp(p, res, N &gt;&gt; 1);
    int *temp = new int[(N &lt;&lt; 1) + 1];
    get_poly_ln(res, temp, N);
    int K = N &lt;&lt; 1;
    for (int i = 0; i &lt; N; i++)
    {
        temp[i] = p[i] - temp[i];
        if (temp[i] &lt; 0)
            temp[i] += MOD;
    }
    if ((++temp[0]) == MOD)
        temp[0] = 0;
    for (int i = N; i &lt; K; i++)
        temp[i] = res[i] = 0;
    NTT_init(K);
    NTT(temp, K, 1);
    NTT(res, K, 1);
    for (int i = 0; i &lt; K; i++)
        res[i] = (ll)res[i] * (ll)temp[i] % MOD;
    NTT(res, K, -1);
    for (int i = N; i &lt; K; i++)
        res[i] = 0;
    delete[] temp;
}
//对给定n次多项式p (且p[0]==0) ,求出其模MOD以及x^(n+1)意义下的多项式res==exp(p)
void Poly_exp(int *p, int *res, int n)
{
    int N = 2;
    while (N &lt;= n)
        N &lt;&lt;= 1;
    int *temp = new int[(N &lt;&lt; 1) + 1];
    get_poly_exp(p, temp, N);
    for (int i = 0; i &lt;= n; i++)
        res[i] = temp[i];
    delete[] temp;
}
} // namespace Polynomial_exp
using namespace Polynomial_exp;</code></pre><p>(```)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/12/mypoly/" data-id="ck4c4gome0000f8qfdcg346zq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/02/hello-world/" class="article-date">
  <time datetime="2019-11-02T10:26:36.573Z" itemprop="datePublished">2019-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/02/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/02/hello-world/" data-id="ck4c4goms0003f8qf676t5n7s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/19/%E5%A4%A7%E4%B8%80%E4%B8%8A,%E8%8B%A6%E6%81%BC/">大一上,苦恼</a>
          </li>
        
          <li>
            <a href="/2019/12/13/polyarray/">polyarray</a>
          </li>
        
          <li>
            <a href="/2019/12/12/mypoly/">mypoly</a>
          </li>
        
          <li>
            <a href="/2019/11/02/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>